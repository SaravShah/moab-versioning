h2. Component SignatureCatalog

h4. Data Model

* *[#SignatureCatalog] = lookup table containing a cumulative collection of all files ever ingested*
** [#SignatureCatalogEntry] \[1..\*] = an row in the lookup table containing storage information about a single file
*** [#FileSignature] \[1] = file fixity information


h4. Description

A digital object's Signature Catalog is derived from an filtered aggregation of the file inventories
of a digital object's set of versions.  (see [#update])
It has an entry for every file (identified by [#FileSignature]) found in any of the versions,
along with a record of the SDR storage location that was used to preserve a single file instance.
Once this catalog has been populated, it has multiple uses:
* The signature index is used to determine which files of a newly submitted object version
  are new additons and which are duplicates of files previously ingested.  (See [#version_additions])
  (When a new version contains a mixture of added files and files carried over from the previous version
  we only need to store the files from the new version that have unique file signatures.)
* Reconstruction of an object version (see [#StorageObject#reconstruct_version]) requires a combination
  of a full version's [#FileInventory] and the SignatureCatalog.
* The catalog can also be used for performing consistency checks between manifest files and storage


h4. XML Example
{code:lang=xml}
<?xml version="1.0" encoding="UTF-8"?>
<signatureCatalog objectId="druid:jq937jp0017" versionId="3" catalogDatetime="2012-04-19T12:12:48Z" fileCount="19" byteCount="308324" blockCount="309">
  <entry originalVersion="1" groupId="content" storagePath="intro-1.jpg">
    <fileSignature size="41981" md5="915c0305bf50c55143f1506295dc122c" sha1="60448956fbe069979fce6a6e55dba4ce1f915178"/>
  </entry>
  <entry originalVersion="1" groupId="content" storagePath="intro-2.jpg">
    <fileSignature size="39850" md5="77f1a4efdcea6a476505df9b9fba82a7" sha1="a49ae3f3771d99ceea13ec825c9c2b73fc1a9915"/>
  </entry>
  <entry originalVersion="1" groupId="content" storagePath="page-1.jpg">
    <fileSignature size="25153" md5="3dee12fb4f1c28351c7482b76ff76ae4" sha1="906c1314f3ab344563acbbbe2c7930f08429e35b"/>
  </entry>
  <entry originalVersion="1" groupId="content" storagePath="page-2.jpg">
    <fileSignature size="39450" md5="82fc107c88446a3119a51a8663d1e955" sha1="d0857baa307a2e9efff42467b5abd4e1cf40fcd5"/>
  </entry>
  <entry originalVersion="1" groupId="content" storagePath="page-3.jpg">
    <fileSignature size="19125" md5="a5099878de7e2e064432d6df44ca8827" sha1="c0ccac433cf02a6cee89c14f9ba6072a184447a2"/>
  </entry>
  <entry originalVersion="1" groupId="content" storagePath="title.jpg">
    <fileSignature size="40873" md5="1a726cd7963bd6d3ceb10a8c353ec166" sha1="583220e0572640abcd3ddd97393d224e8053a6ad"/>
  </entry>
  <entry originalVersion="1" groupId="metadata" storagePath="contentMetadata.xml">
    <fileSignature size="1619" md5="b886db0d14508884150a916089da840f" sha1="b2328faaf25caf037cfc0263896ad707fc3a47a7"/>
  </entry>
  <entry originalVersion="1" groupId="metadata" storagePath="descMetadata.xml">
    <fileSignature size="3046" md5="a60bb487db6a1ceb5e0b5bb3cae2dfa2" sha1="edefc0e1d7cffd5bd3c7db6a393ab7632b70dc2d"/>
  </entry>
  <entry originalVersion="1" groupId="metadata" storagePath="identityMetadata.xml">
    <fileSignature size="12903" md5="ccb5bf2ae0c2c6ad0b89692fa1e10145" sha1="3badb0d06aef40f14e4664d2594c6060b9e9716b"/>
  </entry>
  <entry originalVersion="1" groupId="metadata" storagePath="provenanceMetadata.xml">
    <fileSignature size="5306" md5="17193dbf595571d728ba59aa31638db9" sha1="c8b91eacf9ad7532a42dc52b3c9cf03b4ad2c7f6"/>
  </entry>
  <entry originalVersion="1" groupId="metadata" storagePath="versionMetadata.xml">
    <fileSignature size="384" md5="f16a2564fae2706a8c82cda6dccdb4d9" sha1="7aaf84f63a1db803d272352f03935d303f066560"/>
  </entry>
  <entry originalVersion="2" groupId="content" storagePath="page-1.jpg">
    <fileSignature size="32915" md5="c1c34634e2f18a354cd3e3e1574c3194" sha1="0616a0bd7927328c364b2ea0b4a79c507ce915ed"/>
  </entry>
  <entry originalVersion="2" groupId="metadata" storagePath="contentMetadata.xml">
    <fileSignature size="1135" md5="d74bfa778653b6c1b285b2d0c2f07c5b" sha1="0ee15e133c17ae3312b87247adb310b0327ca3df"/>
  </entry>
  <entry originalVersion="2" groupId="metadata" storagePath="provenanceMetadata.xml">
    <fileSignature size="564" md5="351e4c872148e0bc9dc24874c7ef6c08" sha1="565473bbc865b1c6f88efc99b6b5b73fd5cadbc8"/>
  </entry>
  <entry originalVersion="2" groupId="metadata" storagePath="versionMetadata.xml">
    <fileSignature size="970" md5="8a3b0051d89a90a6db90edb7b76ef63f" sha1="7e18ec3a00f7e64d561a9c1c2bc2950ef7deea33"/>
  </entry>
  <entry originalVersion="3" groupId="content" storagePath="page-2.jpg">
    <fileSignature size="39539" md5="fe6e3ffa1b02ced189db640f68da0cc2" sha1="43ced73681687bc8e6f483618f0dcff7665e0ba7"/>
  </entry>
  <entry originalVersion="3" groupId="metadata" storagePath="contentMetadata.xml">
    <fileSignature size="1376" md5="44caefdbaf92f808c3fd27d693338c40" sha1="eb6f9c6539c90412bb4994d13311cc8dfe37c334"/>
  </entry>
  <entry originalVersion="3" groupId="metadata" storagePath="provenanceMetadata.xml">
    <fileSignature size="564" md5="17071e4607de4b272f3f06ec76be4c4a" sha1="b796a0b569bde53953ba0835bb47f4009f654349"/>
  </entry>
  <entry originalVersion="3" groupId="metadata" storagePath="versionMetadata.xml">
    <fileSignature size="1571" md5="6ec3d879c5a91922889adc916d991db5" sha1="65c65bedf285fc87c1ea14646bc47e79762359d3"/>
  </entry>
</signatureCatalog>
{code}

h4. XML Nodes
\\
||XML Element||Ruby Class||Inherits From||
|<signatureCatalog>|[#SignatureCatalog]|Manifest|
\\
||XML Child Node||Ruby Attribute||Data Type||Description||
|@objectId|digital_object_id|String|The object ID (druid)|
|@versionId|version_id|Integer|The ordinal version number|
|@catalogDatetime|catalog_datetime|Time|The datetime at which the catalog was updated|
|@fileCount|file_count|Integer|The total number of data files (dynamically calculated)|
|@byteCount|byte_count|Integer|The total size (in bytes) of all data files (dynamically calculated)|
|@blockCount|block_count|Integer|The total disk usage (in 1 kB blocks) of all data files (estimating du -k result) (dynamically calculated)|
|<entry> \[1..\*]|entries|Array<SignatureCatalogEntry>|The set of data groups comprising the version|
\\
||XML Element||Ruby Class||Inherits From||
|<entry>|[#SignatureCatalogEntry]|Serializable|
\\
||XML Child Node||Ruby Attribute||Data Type||Description||
|@originalVersion|version_id|Integer|The ordinal version number|
|@groupId|group_id|String|The name of the file group|
|@storagePath|path|String|The id is the filename path, relative to the file group's base directory|
|<fileSignature>|signature|FileSignature|The fixity data of the file instance|
\\
||XML Element||Ruby Class||Inherits From||
|<fileSignature>|[#FileSignature]|Serializable|
\\
||XML Child Node||Ruby Attribute||Data Type||Description||
|@size|size|Integer|The size of the file in bytes|
|@md5|md5|String|The MD5 checksum value of the file|
|@sha1|sha1|String|The SHA1 checksum value of the file|

{anchor:SignatureCatalog}
h3. Class Moab::SignatureCatalog

h4. Instance Methods

h5. Moab::SignatureCatalog#update
||Method||Return Type||Description||
|update|void|Compares the [#FileSignature] entries in the new versions [#FileInventory] against the signatures in this catalog and create new [#SignatureCatalogEntry] addtions to the catalog|

||Parameter||Data Type||Description||
|version_inventory|FileInventory|The complete inventory of the files comprising a digital object version|
{code:lang=none|title=Ruby Source Code}
def update(version_inventory)
  version_inventory.groups.each do |group|
    group.files.each do |file|
      unless @signature_hash.has_key?(file.signature)
        entry = SignatureCatalogEntry.new
        entry.version_id = version_inventory.version_id
        entry.group_id = group.group_id
        entry.path = file.instances[0].path
        entry.signature = file.signature
        add_entry(entry)
      end
    end
  end
  @version_id = version_inventory.version_id
  @catalog_datetime = Time.now
end{code}

{code:lang=none|title=Usage Example}
require 'spec_helper'

feature "Determine version's file additions" do
  #  In order to: know which files are new or modified in a new version
  #  The application needs to: compare file signatures against the signature catalog

  scenario "Generate versionAdditions report" do
    # given: previous version's signature catalog
    #      : and new version's file inventory
    # action: filter the new inventory against the catalog
    # outcome: version addtions report

    v1_catalog_pathname = @fixtures.join('derivatives/ingests/jq937jp0017/v0001/signatureCatalog.xml')
    signature_catalog = SignatureCatalog.parse(v1_catalog_pathname.read)
    v2_inventory_pathname = @fixtures.join('derivatives/ingests/jq937jp0017/v0002/versionInventory.xml')
    v2_inventory = FileInventory.parse(v2_inventory_pathname.read)
    original_entry_count = signature_catalog.entries.count
    signature_catalog.update(v2_inventory)
    signature_catalog.entries.count.should == original_entry_count + 4
  end

end{code}

h5. Moab::SignatureCatalog#version_additions
||Method||Return Type||Description||
|version_additions|FileInventory|Retrurns a filtered copy of the input inventory containing only those files that were added in this version|

||Parameter||Data Type||Description||
|version_inventory|FileInventory|The complete inventory of the files comprising a digital object version|
{code:lang=none|title=Ruby Source Code}
def version_additions(version_inventory)
  version_additions = FileInventory.new(:type=>'additions')
  version_additions.copy_ids(version_inventory)
  version_inventory.groups.each do |group|
    group_addtions = FileGroup.new(:group_id => group.group_id)
    group.files.each do |file|
      unless @signature_hash.has_key?(file.signature)
        group_addtions.add_file_instance(file.signature,file.instances[0])
      end
    end
    version_additions.groups << group_addtions if group_addtions.files.size > 0
  end
  version_additions
end{code}

{code:lang=none|title=Usage Example}
require 'spec_helper'

feature "Determine version's file additions" do
  #  In order to: know which files are new or modified in a new version
  #  The application needs to: compare file signatures against the signature catalog

  scenario "Generate versionAdditions report" do
    # given: previous version's signature catalog
    #      : and new version's file inventory
    # action: filter the new inventory against the catalog
    # outcome: version addtions report

    v1_catalog_pathname = @fixtures.join('derivatives/ingests/jq937jp0017/v0001/signatureCatalog.xml')
    signature_catalog = SignatureCatalog.parse(v1_catalog_pathname.read)
    v2_inventory_pathname = @fixtures.join('derivatives/ingests/jq937jp0017/v0002/versionInventory.xml')
    v2_inventory = FileInventory.parse(v2_inventory_pathname.read)
    version_additions = signature_catalog.version_additions(v2_inventory)
    version_additions.groups.count.should == 2
    version_additions.file_count.should == 4
    version_additions.byte_count.should == 35584
    version_additions.block_count.should == 37
  end

end{code}

{anchor:SignatureCatalogEntry}
h3. Class Moab::SignatureCatalogEntry

h4. Description

A file-level entry in a digital object's [#SignatureCatalog].
It has a child [#FileSignature] element that identifies the file's contents (the bytestream)
along with data that specfies the SDR storage location that was used to preserve a single file instance.



{anchor:FileSignature}
h3. Class Moab::FileSignature

h4. Description

The fixity properties of a file, used to determine file content equivalence regardless of filename.


