
{anchor:StorageObject}
h2. Class Moab::StorageObject

h4. Description

A class to represent a digital object's repository storage location
and methods for
* packaging a bag for ingest of a new object version to the repository
* ingesting a bag
* disseminating a bag containing a reconstructed object version

h4. Data Model
* *[#StorageObject] = represents a digital object's repository storage location and ingest/dissemination methods*
** [#StorageObjectVersion] \[1..\*] = represents a version subdirectory within an object's home directory
*** [#Bagger] \[1] = utility for creating bagit packages for ingest or dissemination

 
||XML Element||Ruby Class||Inherits From||
|-|StorageObject|Object|

||XML Child Node||Ruby Attribute||Data Type||Description||
|-|digital_object_id|String|The digital object ID (druid)|
|-|object_pathname|Pathname|The location of the object's storage home directory|

h3. Class Methods
 
h5. Moab::StorageObject.version_dirname
||Method||Return Type||Description||
|version_dirname|String|The directory name of the version, relative to the digital object home directory (e.g v0002)|
 
||Parameter||Data Type||Description||
|version_id|Integer|The version identifier of an object version|
{code:lang=none|title=Ruby Source Code}
def self.version_dirname(version_id)
  ("v%04d" % version_id)
end
{code}

h3. Instance Methods
 
h5. Moab::StorageObject#initialize_storage
||Method||Return Type||Description||
|initialize_storage|void|Create the directory for the digital object home unless it already exists|
{code:lang=none|title=Ruby Source Code}
def initialize_storage
  @object_pathname.mkpath
end
{code}
 
h5. Moab::StorageObject#ingest_bag
||Method||Return Type||Description||
|ingest_bag|void|Ingest a new object version contained in a bag into this objects storage area|
 
||Parameter||Data Type||Description||
|bag_dir|Pathname, String|The location of the bag to be ingested|
{code:lang=none|title=Ruby Source Code}
def ingest_bag(bag_dir)
  current_version = StorageObjectVersion.new(self,current_version_id)
  current_inventory = current_version.file_inventory('version')
  new_version = StorageObjectVersion.new(self,current_version_id + 1)
  new_inventory = FileInventory.read_xml_file(bag_dir,'version')
  validate_new_inventory(new_inventory)
  new_version.ingest_bag_data(bag_dir)
  new_version.update_catalog(current_version.signature_catalog,new_inventory)
  new_version.generate_differences_report(current_inventory,new_inventory)
  new_version.inventory_manifests
  #update_tagmanifests(new_catalog_pathname)
end
{code}

{code:lang=none|title=Usage Example}
require 'spec_helper'

feature "Import digital object version to SDR" do
  #  In order to: ingest a new version of a digital object into SDR
  #  The application needs to: process a Bagit bag containing either a full set or subset of object files

  scenario "Create a new version storage folder" do
    # given: A Bagit bag containing a version of a digital object
    # action: Parse the file inventory for the version,
    #       : create the new version's storage folder,
    #       : copy the version's data files into storage,
    #       : update the object's signature catalog,
    #       : generate a version differences report,
    #       : and generate an inventory of all the manifest files
    # outcome: version storage folder

    ingests_dir = @temp.join('ingests')
    ingests_dir.rmtree if ingests_dir.exist?
    (1..3).each do |version|
      vname = ['','v1','v2','v3'][version]
      object_dir = ingests_dir.join(@obj)
      object_dir.mkpath
      unless object_dir.join("v000#{version}").exist?
        bag_dir = @packages.join(vname)
        StorageObject.new(@druid,object_dir).ingest_bag(bag_dir)
      end
    end

    files = Array.new
    ingests_dir.find { |f| files << f.relative_path_from(@temp).to_s }
    files.sort.should == [
        "ingests",
        "ingests/jq937jp0017",
        "ingests/jq937jp0017/v0001",
        "ingests/jq937jp0017/v0001/data",
        "ingests/jq937jp0017/v0001/data/content",
        "ingests/jq937jp0017/v0001/data/content/intro-1.jpg",
        "ingests/jq937jp0017/v0001/data/content/intro-2.jpg",
        "ingests/jq937jp0017/v0001/data/content/page-1.jpg",
        "ingests/jq937jp0017/v0001/data/content/page-2.jpg",
        "ingests/jq937jp0017/v0001/data/content/page-3.jpg",
        "ingests/jq937jp0017/v0001/data/content/title.jpg",
        "ingests/jq937jp0017/v0001/data/metadata",
        "ingests/jq937jp0017/v0001/data/metadata/contentMetadata.xml",
        "ingests/jq937jp0017/v0001/data/metadata/descMetadata.xml",
        "ingests/jq937jp0017/v0001/data/metadata/identityMetadata.xml",
        "ingests/jq937jp0017/v0001/data/metadata/provenanceMetadata.xml",
        "ingests/jq937jp0017/v0001/data/metadata/versionMetadata.xml",
        "ingests/jq937jp0017/v0001/fileInventoryDifference.xml",
        "ingests/jq937jp0017/v0001/manifestInventory.xml",
        "ingests/jq937jp0017/v0001/signatureCatalog.xml",
        "ingests/jq937jp0017/v0001/versionAdditions.xml",
        "ingests/jq937jp0017/v0001/versionInventory.xml",
        "ingests/jq937jp0017/v0002",
        "ingests/jq937jp0017/v0002/data",
        "ingests/jq937jp0017/v0002/data/content",
        "ingests/jq937jp0017/v0002/data/content/page-1.jpg",
        "ingests/jq937jp0017/v0002/data/metadata",
        "ingests/jq937jp0017/v0002/data/metadata/contentMetadata.xml",
        "ingests/jq937jp0017/v0002/data/metadata/provenanceMetadata.xml",
        "ingests/jq937jp0017/v0002/data/metadata/versionMetadata.xml",
        "ingests/jq937jp0017/v0002/fileInventoryDifference.xml",
        "ingests/jq937jp0017/v0002/manifestInventory.xml",
        "ingests/jq937jp0017/v0002/signatureCatalog.xml",
        "ingests/jq937jp0017/v0002/versionAdditions.xml",
        "ingests/jq937jp0017/v0002/versionInventory.xml",
        "ingests/jq937jp0017/v0003",
        "ingests/jq937jp0017/v0003/data",
        "ingests/jq937jp0017/v0003/data/content",
        "ingests/jq937jp0017/v0003/data/content/page-2.jpg",
        "ingests/jq937jp0017/v0003/data/metadata",
        "ingests/jq937jp0017/v0003/data/metadata/contentMetadata.xml",
        "ingests/jq937jp0017/v0003/data/metadata/provenanceMetadata.xml",
        "ingests/jq937jp0017/v0003/data/metadata/versionMetadata.xml",
        "ingests/jq937jp0017/v0003/fileInventoryDifference.xml",
        "ingests/jq937jp0017/v0003/manifestInventory.xml",
        "ingests/jq937jp0017/v0003/signatureCatalog.xml",
        "ingests/jq937jp0017/v0003/versionAdditions.xml",
        "ingests/jq937jp0017/v0003/versionInventory.xml"
    ]
    ingests_dir.rmtree if ingests_dir.exist?  end


end
{code}
 
h5. Moab::StorageObject#reconstruct_version
||Method||Return Type||Description||
|reconstruct_version|void|Reconstruct an object version and package it in a bag for dissemination|
 
||Parameter||Data Type||Description||
|version_id|Integer|The version identifier of the object version to be disseminated|
|bag_dir|Pathname, String|The location of the bag to be created|
{code:lang=none|title=Ruby Source Code}
def reconstruct_version(version_id, bag_dir)
  storage_version = StorageObjectVersion.new(self,version_id)
  version_inventory = storage_version.file_inventory('version')
  signature_catalog = storage_version.signature_catalog
  bagger = Bagger.new(version_inventory, signature_catalog, @object_pathname, bag_dir)
  bagger.fill_bag(:reconstructor)
end
{code}

{code:lang=none|title=Usage Example}
require 'spec_helper'

feature "Create reconstructed digital object for a version" do
  #  In order to: disseminate a copy of a digital object version
  #  The application needs to: reconstruct the version's file structure from the storage location

  scenario "Generate a copy of a full version in a temp location" do
    # given: the repository storage location containing the files from all the object versions
    #      : the file inventory for the desired version
    #      : the file signature catalog for the object
    # action: copy (link) files to the temp location,
    #       : using the signature catalog to locate files
    #       : and the version's file inventory to provide original filenames
    # outcome: a temp folder containing the version's files

    reconstructs_dir = @temp.join('reconstructs')
    reconstructs_dir.rmtree if reconstructs_dir.exist?
    (1..3).each do |version|
      vname = ['','v1','v2','v3'][version]
      bag_dir = reconstructs_dir.join(vname)
      unless bag_dir.exist?
        object_dir = @ingests.join(@obj)
        StorageObject.new(@druid,object_dir).reconstruct_version(version, bag_dir)
      end
    end

    files = Array.new
    reconstructs_dir.find { |f| files << f.relative_path_from(@temp).to_s }
    files.sort.should == [
        "reconstructs",
        "reconstructs/v1",
        "reconstructs/v1/bag-info.txt",
        "reconstructs/v1/bagit.txt",
        "reconstructs/v1/data",
        "reconstructs/v1/data/content",
        "reconstructs/v1/data/content/intro-1.jpg",
        "reconstructs/v1/data/content/intro-2.jpg",
        "reconstructs/v1/data/content/page-1.jpg",
        "reconstructs/v1/data/content/page-2.jpg",
        "reconstructs/v1/data/content/page-3.jpg",
        "reconstructs/v1/data/content/title.jpg",
        "reconstructs/v1/data/metadata",
        "reconstructs/v1/data/metadata/contentMetadata.xml",
        "reconstructs/v1/data/metadata/descMetadata.xml",
        "reconstructs/v1/data/metadata/identityMetadata.xml",
        "reconstructs/v1/data/metadata/provenanceMetadata.xml",
        "reconstructs/v1/data/metadata/versionMetadata.xml",
        "reconstructs/v1/manifest-md5.txt",
        "reconstructs/v1/manifest-sha1.txt",
        "reconstructs/v1/tagmanifest-md5.txt",
        "reconstructs/v1/tagmanifest-sha1.txt",
        "reconstructs/v1/versionInventory.xml",
        "reconstructs/v2",
        "reconstructs/v2/bag-info.txt",
        "reconstructs/v2/bagit.txt",
        "reconstructs/v2/data",
        "reconstructs/v2/data/content",
        "reconstructs/v2/data/content/page-1.jpg",
        "reconstructs/v2/data/content/page-2.jpg",
        "reconstructs/v2/data/content/page-3.jpg",
        "reconstructs/v2/data/content/title.jpg",
        "reconstructs/v2/data/metadata",
        "reconstructs/v2/data/metadata/contentMetadata.xml",
        "reconstructs/v2/data/metadata/descMetadata.xml",
        "reconstructs/v2/data/metadata/identityMetadata.xml",
        "reconstructs/v2/data/metadata/provenanceMetadata.xml",
        "reconstructs/v2/data/metadata/versionMetadata.xml",
        "reconstructs/v2/manifest-md5.txt",
        "reconstructs/v2/manifest-sha1.txt",
        "reconstructs/v2/tagmanifest-md5.txt",
        "reconstructs/v2/tagmanifest-sha1.txt",
        "reconstructs/v2/versionInventory.xml",
        "reconstructs/v3",
        "reconstructs/v3/bag-info.txt",
        "reconstructs/v3/bagit.txt",
        "reconstructs/v3/data",
        "reconstructs/v3/data/content",
        "reconstructs/v3/data/content/page-1.jpg",
        "reconstructs/v3/data/content/page-2.jpg",
        "reconstructs/v3/data/content/page-3.jpg",
        "reconstructs/v3/data/content/page-4.jpg",
        "reconstructs/v3/data/content/title.jpg",
        "reconstructs/v3/data/metadata",
        "reconstructs/v3/data/metadata/contentMetadata.xml",
        "reconstructs/v3/data/metadata/descMetadata.xml",
        "reconstructs/v3/data/metadata/identityMetadata.xml",
        "reconstructs/v3/data/metadata/provenanceMetadata.xml",
        "reconstructs/v3/data/metadata/versionMetadata.xml",
        "reconstructs/v3/manifest-md5.txt",
        "reconstructs/v3/manifest-sha1.txt",
        "reconstructs/v3/tagmanifest-md5.txt",
        "reconstructs/v3/tagmanifest-sha1.txt",
        "reconstructs/v3/versionInventory.xml"
    ]
    reconstructs_dir.rmtree if reconstructs_dir.exist?
  end

end
{code}
 
h5. Moab::StorageObject#current_version_id
||Method||Return Type||Description||
|current_version_id|Integer|The identifier of the latest version of this object|
{code:lang=none|title=Ruby Source Code}
def current_version_id
  return @current_version_id unless @current_version_id.nil?
  version_id = 0
  @object_pathname.children.each do |dirname|
    vnum = dirname.basename.to_s
    if vnum.match /^v(\d+)$/
      v = vnum[1..-1].to_i
      version_id = v > version_id ? v : version_id
    end
  end
  @current_version_id = version_id
end
{code}
 
----

{anchor:StorageObjectVersion}
h2. Class Moab::StorageObjectVersion

h4. Description

A class to represent a version subdirectory with an object's home directory in preservation storage

h4. Data Model
* [#StorageObject] = represents a digital object's repository storage location and ingest/dissemination methods
** *[#StorageObjectVersion] \[1..\*] = represents a version subdirectory within an object's home directory*
*** [#Bagger] \[1] = utility for creating bagit packages for ingest or dissemination

 
||XML Element||Ruby Class||Inherits From||
|-|StorageObjectVersion|Object|

||XML Child Node||Ruby Attribute||Data Type||Description||
|-|version_id|Integer|The ordinal version number|
|-|version_name|String|The "v0001" directory name derived from the version id|
|-|version_pathname|Pathname|The location of the version inside the home directory|
|-|storage_object|Pathname|The location of the object's home directory|

h3. Instance Methods
 
h5. Moab::StorageObjectVersion#file_inventory
||Method||Return Type||Description||
|file_inventory|FileInventory|The file inventory of the specified type for this version|
 
||Parameter||Data Type||Description||
|type|String|The type of inventory to return (version\|additions\|manifests)|
{code:lang=none|title=Ruby Source Code}
def file_inventory(type)
  if version_id > 0
    FileInventory.read_xml_file(@version_pathname, type)
  else
    groups = ['content','metadata'].collect { |id| FileGroup.new(:group_id=>id)}
    FileInventory.new(
        :type=>'version',
        :digital_object_id => @storage_object.digital_object_id,
        :version_id => @version_id,
        :groups => groups
    )

  end
end
{code}
 
h5. Moab::StorageObjectVersion#signature_catalog
||Method||Return Type||Description||
|signature_catalog|SignatureCatalog|The signature catalog of the digital object as of this version|
{code:lang=none|title=Ruby Source Code}
def signature_catalog
  if version_id > 0
    SignatureCatalog.read_xml_file(@version_pathname)
  else
    SignatureCatalog.new(:digital_object_id => @storage_object.digital_object_id)
  end
end
{code}
 
----

{anchor:Bagger}
h2. Class Moab::Bagger

h4. Description

A class used to create a BagIt package from a version inventory and a set of source files.
The [#fill_bag] method is called with a package_mode parameter that specifies
whether the bag is being created for deposit into the repository or is to contain the output of a version reconstruction.
* In *:depositor* mode, the version inventory is filtered using the digital object's signature catalog so that only new files are included
* In *:reconstructor* mode, the version inventory and signature catalog are used together to regenerate the complete set of files for the version.

h4. Data Model
* [#StorageObject] = represents a digital object's repository storage location and ingest/dissemination methods
** [#StorageObjectVersion] \[1..\*] = represents a version subdirectory within an object's home directory
*** *[#Bagger] \[1] = utility for creating bagit packages for ingest or dissemination*

 
||XML Element||Ruby Class||Inherits From||
|-|Bagger|Object|

||XML Child Node||Ruby Attribute||Data Type||Description||
|-|version_inventory|FileInventory|The complete inventory of the files comprising a digital object version|
|-|signature_catalog|SignatureCatalog|The signature catalog, used to specify source paths (in :reconstructor mode), or to filter the version inventory (in :depositor mode)|
|-|source_base_pathname|Pathname|The home location of the source files|
|-|bag_pathname|Pathname|The location of the Bagit bag to be created|
|-|bag_inventory|FileInventory|The actual inventory of the files to be packaged (derived from @version_inventory in [#fill_bag])|
|-|package_mode|Symbol|The operational mode controlling what gets bagged [#fill_bag] and the full path of source files [#fill_payload]|

h3. Instance Methods
 
h5. Moab::Bagger#fill_bag
||Method||Return Type||Description||
|fill_bag|Bagger|Perform all the operations required to fill the bag payload, write the manifests and tagfiles, and checksum the tagfiles|
 
||Parameter||Data Type||Description||
|package_mode|Symbol|The operational mode controlling what gets bagged and the full path of source files (Bagger#fill_payload)|
{code:lang=none|title=Ruby Source Code}
def fill_bag(package_mode)
  @package_mode = package_mode
  case package_mode
    when :depositor
      @bag_inventory = @signature_catalog.version_additions(@version_inventory)
    when :reconstructor
      @bag_inventory = @version_inventory
  end
  @bag_pathname.mkpath
  write_inventory_file
  fill_payload
  create_payload_manifests
  create_bag_info_txt
  create_bagit_txt
  create_tagfile_manifests
  self
end
{code}

{code:lang=none|title=Usage Example}
require 'spec_helper'

feature "Export a digital object version from DOR" do
  #  In order to: tranfer files and metadata from DOR to SDR
  #  The application needs to: create a Bagit bag containing files and manifests

  scenario "Export content and metadata files for a new version" do
    # given: a workspace directory containing content and metadata subdirectories,
    #      : and a file inventory decribing the version's files,
    #      : and a signature catalog for the digital object
    # action: create a new Bagit container
    #       : with hard links to only new or modified files
    # outcome: Bagit bag containing only new or modified files

    (1..3).each do |version|
      vname = ['','v1','v2','v3'][version]
      data_dir = @data.join(vname)
      inventory = FileInventory.read_xml_file(@manifests.join(vname),'version')
      case version
        when 1
          catalog = SignatureCatalog.new(:digital_object_id => inventory.digital_object_id)
        else
          catalog = SignatureCatalog.read_xml_file(@manifests.join(@vname[version-1]))
      end
      bag_dir = @temp.join('packages',vname)
      bag_dir.rmtree if bag_dir.exist?
      Bagger.new(inventory,catalog,data_dir,bag_dir).fill_bag(:depositor)
    end

    files = Array.new
    @temp.join('packages').find { |f| files << f.relative_path_from(@temp).to_s }
    files.sort.should == [
        "packages",
        "packages/v1",
        "packages/v1/bag-info.txt",
        "packages/v1/bagit.txt",
        "packages/v1/data",
        "packages/v1/data/content",
        "packages/v1/data/content/intro-1.jpg",
        "packages/v1/data/content/intro-2.jpg",
        "packages/v1/data/content/page-1.jpg",
        "packages/v1/data/content/page-2.jpg",
        "packages/v1/data/content/page-3.jpg",
        "packages/v1/data/content/title.jpg",
        "packages/v1/data/metadata",
        "packages/v1/data/metadata/contentMetadata.xml",
        "packages/v1/data/metadata/descMetadata.xml",
        "packages/v1/data/metadata/identityMetadata.xml",
        "packages/v1/data/metadata/provenanceMetadata.xml",
        "packages/v1/data/metadata/versionMetadata.xml",
        "packages/v1/manifest-md5.txt",
        "packages/v1/manifest-sha1.txt",
        "packages/v1/tagmanifest-md5.txt",
        "packages/v1/tagmanifest-sha1.txt",
        "packages/v1/versionAdditions.xml",
        "packages/v1/versionInventory.xml",
        "packages/v2",
        "packages/v2/bag-info.txt",
        "packages/v2/bagit.txt",
        "packages/v2/data",
        "packages/v2/data/content",
        "packages/v2/data/content/page-1.jpg",
        "packages/v2/data/metadata",
        "packages/v2/data/metadata/contentMetadata.xml",
        "packages/v2/data/metadata/provenanceMetadata.xml",
        "packages/v2/data/metadata/versionMetadata.xml",
        "packages/v2/manifest-md5.txt",
        "packages/v2/manifest-sha1.txt",
        "packages/v2/tagmanifest-md5.txt",
        "packages/v2/tagmanifest-sha1.txt",
        "packages/v2/versionAdditions.xml",
        "packages/v2/versionInventory.xml",
        "packages/v3",
        "packages/v3/bag-info.txt",
        "packages/v3/bagit.txt",
        "packages/v3/data",
        "packages/v3/data/content",
        "packages/v3/data/content/page-2.jpg",
        "packages/v3/data/metadata",
        "packages/v3/data/metadata/contentMetadata.xml",
        "packages/v3/data/metadata/provenanceMetadata.xml",
        "packages/v3/data/metadata/versionMetadata.xml",
        "packages/v3/manifest-md5.txt",
        "packages/v3/manifest-sha1.txt",
        "packages/v3/tagmanifest-md5.txt",
        "packages/v3/tagmanifest-sha1.txt",
        "packages/v3/versionAdditions.xml",
        "packages/v3/versionInventory.xml"
    ]
    @temp.join('packages').rmtree
  end
end
{code}
